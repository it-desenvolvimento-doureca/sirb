import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, HostBinding, HostListener, Input, NgModule, NgZone, Output, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { DomSanitizer } from '@angular/platform-browser';

/**
 * @param {?} srcBase64
 * @return {?}
 */
function resetExifOrientation(srcBase64) {
    try {
        const /** @type {?} */ exifRotation = getExifRotation(srcBase64);
        if (exifRotation > 1) {
            return transformBase64BasedOnExifRotation(srcBase64, exifRotation);
        }
        else {
            return Promise.resolve(srcBase64);
        }
    }
    catch (ex) {
        return Promise.reject(ex);
    }
}
/**
 * @param {?} srcBase64
 * @param {?} exifRotation
 * @return {?}
 */
function transformBase64BasedOnExifRotation(srcBase64, exifRotation) {
    return new Promise((resolve, reject) => {
        const /** @type {?} */ img = new Image();
        img.onload = function () {
            const /** @type {?} */ width = img.width;
            const /** @type {?} */ height = img.height;
            const /** @type {?} */ canvas = document.createElement('canvas');
            const /** @type {?} */ ctx = canvas.getContext('2d');
            if (ctx) {
                if (4 < exifRotation && exifRotation < 9) {
                    canvas.width = height;
                    canvas.height = width;
                }
                else {
                    canvas.width = width;
                    canvas.height = height;
                }
                transformCanvas(ctx, exifRotation, width, height);
                ctx.drawImage(img, 0, 0);
                resolve(canvas.toDataURL());
            }
            else {
                reject(new Error('No context'));
            }
        };
        img.src = srcBase64;
    });
}
/**
 * @param {?} imageBase64
 * @return {?}
 */
function getExifRotation(imageBase64) {
    const /** @type {?} */ view = new DataView(base64ToArrayBuffer(imageBase64));
    if (view.getUint16(0, false) != 0xFFD8) {
        return -2;
    }
    const /** @type {?} */ length = view.byteLength;
    let /** @type {?} */ offset = 2;
    while (offset < length) {
        if (view.getUint16(offset + 2, false) <= 8)
            return -1;
        const /** @type {?} */ marker = view.getUint16(offset, false);
        offset += 2;
        if (marker == 0xFFE1) {
            if (view.getUint32(offset += 2, false) != 0x45786966) {
                return -1;
            }
            const /** @type {?} */ little = view.getUint16(offset += 6, false) == 0x4949;
            offset += view.getUint32(offset + 4, little);
            const /** @type {?} */ tags = view.getUint16(offset, little);
            offset += 2;
            for (let /** @type {?} */ i = 0; i < tags; i++) {
                if (view.getUint16(offset + (i * 12), little) == 0x0112) {
                    return view.getUint16(offset + (i * 12) + 8, little);
                }
            }
        }
        else if ((marker & 0xFF00) != 0xFF00) {
            break;
        }
        else {
            offset += view.getUint16(offset, false);
        }
    }
    return -1;
}
/**
 * @param {?} imageBase64
 * @return {?}
 */
function base64ToArrayBuffer(imageBase64) {
    imageBase64 = imageBase64.replace(/^data\:([^\;]+)\;base64,/gmi, '');
    const /** @type {?} */ binaryString = atob(imageBase64);
    const /** @type {?} */ len = binaryString.length;
    const /** @type {?} */ bytes = new Uint8Array(len);
    for (let /** @type {?} */ i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}
/**
 * @param {?} ctx
 * @param {?} orientation
 * @param {?} width
 * @param {?} height
 * @return {?}
 */
function transformCanvas(ctx, orientation, width, height) {
    switch (orientation) {
        case 2:
            ctx.transform(-1, 0, 0, 1, width, 0);
            break;
        case 3:
            ctx.transform(-1, 0, 0, -1, width, height);
            break;
        case 4:
            ctx.transform(1, 0, 0, -1, 0, height);
            break;
        case 5:
            ctx.transform(0, 1, 1, 0, 0, 0);
            break;
        case 6:
            ctx.transform(0, 1, -1, 0, height, 0);
            break;
        case 7:
            ctx.transform(0, -1, -1, 0, height, width);
            break;
        case 8:
            ctx.transform(0, -1, 1, 0, 0, width);
            break;
    }
}

/**
 * @param {?} canvas
 * @param {?} width
 * @param {?} height
 * @param {?=} resizeCanvas
 * @return {?}
 */
function resizeCanvas(canvas, width, height, resizeCanvas = true) {
    const /** @type {?} */ width_source = canvas.width;
    const /** @type {?} */ height_source = canvas.height;
    width = Math.round(width);
    height = Math.round(height);
    const /** @type {?} */ ratio_w = width_source / width;
    const /** @type {?} */ ratio_h = height_source / height;
    const /** @type {?} */ ratio_w_half = Math.ceil(ratio_w / 2);
    const /** @type {?} */ ratio_h_half = Math.ceil(ratio_h / 2);
    const /** @type {?} */ ctx = canvas.getContext('2d');
    if (ctx) {
        const /** @type {?} */ img = ctx.getImageData(0, 0, width_source, height_source);
        const /** @type {?} */ img2 = ctx.createImageData(width, height);
        const /** @type {?} */ data = img.data;
        const /** @type {?} */ data2 = img2.data;
        for (let /** @type {?} */ j = 0; j < height; j++) {
            for (let /** @type {?} */ i = 0; i < width; i++) {
                const /** @type {?} */ x2 = (i + j * width) * 4;
                const /** @type {?} */ center_y = j * ratio_h;
                let /** @type {?} */ weight = 0;
                let /** @type {?} */ weights = 0;
                let /** @type {?} */ weights_alpha = 0;
                let /** @type {?} */ gx_r = 0;
                let /** @type {?} */ gx_g = 0;
                let /** @type {?} */ gx_b = 0;
                let /** @type {?} */ gx_a = 0;
                const /** @type {?} */ xx_start = Math.floor(i * ratio_w);
                const /** @type {?} */ yy_start = Math.floor(j * ratio_h);
                let /** @type {?} */ xx_stop = Math.ceil((i + 1) * ratio_w);
                let /** @type {?} */ yy_stop = Math.ceil((j + 1) * ratio_h);
                xx_stop = Math.min(xx_stop, width_source);
                yy_stop = Math.min(yy_stop, height_source);
                for (let /** @type {?} */ yy = yy_start; yy < yy_stop; yy++) {
                    const /** @type {?} */ dy = Math.abs(center_y - yy) / ratio_h_half;
                    const /** @type {?} */ center_x = i * ratio_w;
                    const /** @type {?} */ w0 = dy * dy; //pre-calc part of w
                    for (let /** @type {?} */ xx = xx_start; xx < xx_stop; xx++) {
                        const /** @type {?} */ dx = Math.abs(center_x - xx) / ratio_w_half;
                        const /** @type {?} */ w = Math.sqrt(w0 + dx * dx);
                        if (w >= 1) {
                            //pixel too far
                            continue;
                        }
                        //hermite filter
                        weight = 2 * w * w * w - 3 * w * w + 1;
                        const /** @type {?} */ pos_x = 4 * (xx + yy * width_source);
                        //alpha
                        gx_a += weight * data[pos_x + 3];
                        weights_alpha += weight;
                        //colors
                        if (data[pos_x + 3] < 255)
                            weight = weight * data[pos_x + 3] / 250;
                        gx_r += weight * data[pos_x];
                        gx_g += weight * data[pos_x + 1];
                        gx_b += weight * data[pos_x + 2];
                        weights += weight;
                    }
                }
                data2[x2] = gx_r / weights;
                data2[x2 + 1] = gx_g / weights;
                data2[x2 + 2] = gx_b / weights;
                data2[x2 + 3] = gx_a / weights_alpha;
            }
        }
        //clear and resize canvas
        if (resizeCanvas) {
            canvas.width = width;
            canvas.height = height;
        }
        else {
            ctx.clearRect(0, 0, width_source, height_source);
        }
        //draw
        ctx.putImageData(img2, 0, 0);
    }
}
/**
 * @param {?} srcBase64
 * @param {?} aspectRatio
 * @return {?}
 */
function fitImageToAspectRatio(srcBase64, aspectRatio) {
    return new Promise((resolve, reject) => {
        const /** @type {?} */ img = new Image();
        img.onload = function () {
            const /** @type {?} */ canvas = document.createElement('canvas');
            const /** @type {?} */ ctx = canvas.getContext('2d');
            if (ctx) {
                const /** @type {?} */ minWidthToContain = img.height * aspectRatio;
                const /** @type {?} */ minHeightToContain = img.width / aspectRatio;
                canvas.width = Math.max(img.width, minWidthToContain);
                canvas.height = Math.max(img.height, minHeightToContain);
                const /** @type {?} */ dx = (canvas.width - img.width) / 2;
                const /** @type {?} */ dy = (canvas.height - img.height) / 2;
                ctx.drawImage(img, dx, dy);
                resolve(canvas.toDataURL());
            }
            else {
                reject(new Error('No context'));
            }
        };
        img.src = srcBase64;
    });
}

class ImageCropperComponent {
    /**
     * @param {?} sanitizer
     * @param {?} cd
     * @param {?} zone
     */
    constructor(sanitizer, cd, zone) {
        this.sanitizer = sanitizer;
        this.cd = cd;
        this.zone = zone;
        this.setImageMaxSizeRetries = 0;
        this.cropperScaledMinWidth = 20;
        this.cropperScaledMinHeight = 20;
        this.marginLeft = '0px';
        this.imageVisible = false;
        this.format = 'png';
        this.outputType = 'both';
        this.maintainAspectRatio = true;
        this.aspectRatio = 1;
        this.resizeToWidth = 0;
        this.resizeToHeight = 0;
        this.cropperMinWidth = 0;
        this.cropperMinHeight = 0;
        this.roundCropper = false;
        this.onlyScaleDown = false;
        this.imageQuality = 92;
        this.autoCrop = true;
        this.containWithinAspectRatio = false;
        this.cropper = {
            x1: -100,
            y1: -100,
            x2: 10000,
            y2: 10000
        };
        this.alignImage = 'center';
        this.startCropImage = new EventEmitter();
        this.imageCropped = new EventEmitter();
        this.imageCroppedBase64 = new EventEmitter();
        this.imageCroppedFile = new EventEmitter();
        this.imageLoaded = new EventEmitter();
        this.cropperReady = new EventEmitter();
        this.loadImageFailed = new EventEmitter();
        this.initCropper();
    }
    /**
     * @param {?} file
     * @return {?}
     */
    set imageFileChanged(file) {
        this.initCropper();
        if (file) {
            this.loadImageFile(file);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    set imageChangedEvent(event) {
        this.initCropper();
        if (event && event.target && event.target.files && event.target.files.length > 0) {
            this.loadImageFile(event.target.files[0]);
        }
    }
    /**
     * @param {?} imageBase64
     * @return {?}
     */
    set imageBase64(imageBase64) {
        this.initCropper();
        this.checkExifAndLoadBase64Image(imageBase64);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.cropper) {
            this.setMaxSize();
            this.setCropperScaledMinSize();
            this.checkCropperPosition(false);
            this.doAutoCrop();
            this.cd.markForCheck();
        }
        if (changes.aspectRatio && this.imageVisible) {
            this.resetCropperPosition();
        }
    }
    /**
     * @return {?}
     */
    initCropper() {
        this.imageVisible = false;
        this.originalImage = null;
        this.safeImgDataUrl = 'data:image/png;base64,iVBORw0KGg'
            + 'oAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAU'
            + 'AAarVyFEAAAAASUVORK5CYII=';
        this.moveStart = {
            active: false,
            type: null,
            position: null,
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            clientX: 0,
            clientY: 0
        };
        this.maxSize = {
            width: 0,
            height: 0
        };
        this.originalSize = {
            width: 0,
            height: 0
        };
        this.cropper.x1 = -100;
        this.cropper.y1 = -100;
        this.cropper.x2 = 10000;
        this.cropper.y2 = 10000;
    }
    /**
     * @param {?} file
     * @return {?}
     */
    loadImageFile(file) {
        const /** @type {?} */ fileReader = new FileReader();
        fileReader.onload = (event) => {
            const /** @type {?} */ imageType = file.type;
            if (this.isValidImageType(imageType)) {
                this.checkExifAndLoadBase64Image(event.target.result);
            }
            else {
                this.loadImageFailed.emit();
            }
        };
        fileReader.readAsDataURL(file);
    }
    /**
     * @param {?} type
     * @return {?}
     */
    isValidImageType(type) {
        return /image\/(png|jpg|jpeg|bmp|gif|tiff)/.test(type);
    }
    /**
     * @param {?} imageBase64
     * @return {?}
     */
    checkExifAndLoadBase64Image(imageBase64) {
        resetExifOrientation(imageBase64)
            .then((resultBase64) => this.fitImageToAspectRatio(resultBase64))
            .then((resultBase64) => this.loadBase64Image(resultBase64))
            .catch(() => this.loadImageFailed.emit());
    }
    /**
     * @param {?} imageBase64
     * @return {?}
     */
    fitImageToAspectRatio(imageBase64) {
        return this.containWithinAspectRatio
            ? fitImageToAspectRatio(imageBase64, this.aspectRatio)
            : Promise.resolve(imageBase64);
    }
    /**
     * @param {?} imageBase64
     * @return {?}
     */
    loadBase64Image(imageBase64) {
        this.originalBase64 = imageBase64;
        this.safeImgDataUrl = this.sanitizer.bypassSecurityTrustResourceUrl(imageBase64);
        this.originalImage = new Image();
        this.originalImage.onload = () => {
            this.originalSize.width = this.originalImage.width;
            this.originalSize.height = this.originalImage.height;
            this.cd.markForCheck();
        };
        this.originalImage.src = imageBase64;
    }
    /**
     * @return {?}
     */
    imageLoadedInView() {
        if (this.originalImage != null) {
            this.imageLoaded.emit();
            this.setImageMaxSizeRetries = 0;
            setTimeout(() => this.checkImageMaxSizeRecursively());
        }
    }
    /**
     * @return {?}
     */
    checkImageMaxSizeRecursively() {
        if (this.setImageMaxSizeRetries > 40) {
            this.loadImageFailed.emit();
        }
        else if (this.sourceImage && this.sourceImage.nativeElement && this.sourceImage.nativeElement.offsetWidth > 0) {
            this.setMaxSize();
            this.setCropperScaledMinSize();
            this.resetCropperPosition();
            this.cropperReady.emit();
            this.cd.markForCheck();
        }
        else {
            this.setImageMaxSizeRetries++;
            setTimeout(() => {
                this.checkImageMaxSizeRecursively();
            }, 50);
        }
    }
    /**
     * @return {?}
     */
    onResize() {
        this.resizeCropperPosition();
        this.setMaxSize();
        this.setCropperScaledMinSize();
    }
    /**
     * @return {?}
     */
    rotateLeft() {
        this.transformBase64(8);
    }
    /**
     * @return {?}
     */
    rotateRight() {
        this.transformBase64(6);
    }
    /**
     * @return {?}
     */
    flipHorizontal() {
        this.transformBase64(2);
    }
    /**
     * @return {?}
     */
    flipVertical() {
        this.transformBase64(4);
    }
    /**
     * @param {?} exifOrientation
     * @return {?}
     */
    transformBase64(exifOrientation) {
        if (this.originalBase64) {
            transformBase64BasedOnExifRotation(this.originalBase64, exifOrientation)
                .then((resultBase64) => this.fitImageToAspectRatio(resultBase64))
                .then((rotatedBase64) => this.loadBase64Image(rotatedBase64));
        }
    }
    /**
     * @return {?}
     */
    resizeCropperPosition() {
        const /** @type {?} */ sourceImageElement = this.sourceImage.nativeElement;
        if (this.maxSize.width !== sourceImageElement.offsetWidth || this.maxSize.height !== sourceImageElement.offsetHeight) {
            this.cropper.x1 = this.cropper.x1 * sourceImageElement.offsetWidth / this.maxSize.width;
            this.cropper.x2 = this.cropper.x2 * sourceImageElement.offsetWidth / this.maxSize.width;
            this.cropper.y1 = this.cropper.y1 * sourceImageElement.offsetHeight / this.maxSize.height;
            this.cropper.y2 = this.cropper.y2 * sourceImageElement.offsetHeight / this.maxSize.height;
        }
    }
    /**
     * @return {?}
     */
    resetCropperPosition() {
        const /** @type {?} */ sourceImageElement = this.sourceImage.nativeElement;
        if (!this.maintainAspectRatio) {
            this.cropper.x1 = 0;
            this.cropper.x2 = sourceImageElement.offsetWidth;
            this.cropper.y1 = 0;
            this.cropper.y2 = sourceImageElement.offsetHeight;
        }
        else if (sourceImageElement.offsetWidth / this.aspectRatio < sourceImageElement.offsetHeight) {
            this.cropper.x1 = 0;
            this.cropper.x2 = sourceImageElement.offsetWidth;
            const /** @type {?} */ cropperHeight = sourceImageElement.offsetWidth / this.aspectRatio;
            this.cropper.y1 = (sourceImageElement.offsetHeight - cropperHeight) / 2;
            this.cropper.y2 = this.cropper.y1 + cropperHeight;
        }
        else {
            this.cropper.y1 = 0;
            this.cropper.y2 = sourceImageElement.offsetHeight;
            const /** @type {?} */ cropperWidth = sourceImageElement.offsetHeight * this.aspectRatio;
            this.cropper.x1 = (sourceImageElement.offsetWidth - cropperWidth) / 2;
            this.cropper.x2 = this.cropper.x1 + cropperWidth;
        }
        this.doAutoCrop();
        this.imageVisible = true;
    }
    /**
     * @param {?} event
     * @param {?} moveType
     * @param {?=} position
     * @return {?}
     */
    startMove(event, moveType, position = null) {
        event.preventDefault();
        this.moveStart = Object.assign({ active: true, type: moveType, position, clientX: this.getClientX(event), clientY: this.getClientY(event) }, this.cropper);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    moveImg(event) {
        if (this.moveStart.active) {
            event.stopPropagation();
            event.preventDefault();
            if (this.moveStart.type === 'move') {
                this.move(event);
                this.checkCropperPosition(true);
            }
            else if (this.moveStart.type === 'resize') {
                this.resize(event);
                this.checkCropperPosition(false);
            }
            this.cd.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    setMaxSize() {
        const /** @type {?} */ sourceImageElement = this.sourceImage.nativeElement;
        this.maxSize.width = sourceImageElement.offsetWidth;
        this.maxSize.height = sourceImageElement.offsetHeight;
        this.marginLeft = this.sanitizer.bypassSecurityTrustStyle('calc(50% - ' + this.maxSize.width / 2 + 'px)');
    }
    /**
     * @return {?}
     */
    setCropperScaledMinSize() {
        if (this.originalImage) {
            this.setCropperScaledMinWidth();
            this.setCropperScaledMinHeight();
        }
        else {
            this.cropperScaledMinWidth = 20;
            this.cropperScaledMinHeight = 20;
        }
    }
    /**
     * @return {?}
     */
    setCropperScaledMinWidth() {
        this.cropperScaledMinWidth = this.cropperMinWidth > 0
            ? Math.max(20, this.cropperMinWidth / this.originalImage.width * this.maxSize.width)
            : 20;
    }
    /**
     * @return {?}
     */
    setCropperScaledMinHeight() {
        if (this.maintainAspectRatio) {
            this.cropperScaledMinHeight = Math.max(20, this.cropperScaledMinWidth / this.aspectRatio);
        }
        else if (this.cropperMinHeight > 0) {
            this.cropperScaledMinHeight = Math.max(20, this.cropperMinHeight / this.originalImage.height * this.maxSize.height);
        }
        else {
            this.cropperScaledMinHeight = 20;
        }
    }
    /**
     * @param {?=} maintainSize
     * @return {?}
     */
    checkCropperPosition(maintainSize = false) {
        if (this.cropper.x1 < 0) {
            this.cropper.x2 -= maintainSize ? this.cropper.x1 : 0;
            this.cropper.x1 = 0;
        }
        if (this.cropper.y1 < 0) {
            this.cropper.y2 -= maintainSize ? this.cropper.y1 : 0;
            this.cropper.y1 = 0;
        }
        if (this.cropper.x2 > this.maxSize.width) {
            this.cropper.x1 -= maintainSize ? (this.cropper.x2 - this.maxSize.width) : 0;
            this.cropper.x2 = this.maxSize.width;
        }
        if (this.cropper.y2 > this.maxSize.height) {
            this.cropper.y1 -= maintainSize ? (this.cropper.y2 - this.maxSize.height) : 0;
            this.cropper.y2 = this.maxSize.height;
        }
    }
    /**
     * @return {?}
     */
    moveStop() {
        if (this.moveStart.active) {
            this.moveStart.active = false;
            this.doAutoCrop();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    move(event) {
        const /** @type {?} */ diffX = this.getClientX(event) - this.moveStart.clientX;
        const /** @type {?} */ diffY = this.getClientY(event) - this.moveStart.clientY;
        this.cropper.x1 = this.moveStart.x1 + diffX;
        this.cropper.y1 = this.moveStart.y1 + diffY;
        this.cropper.x2 = this.moveStart.x2 + diffX;
        this.cropper.y2 = this.moveStart.y2 + diffY;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    resize(event) {
        const /** @type {?} */ diffX = this.getClientX(event) - this.moveStart.clientX;
        const /** @type {?} */ diffY = this.getClientY(event) - this.moveStart.clientY;
        switch (this.moveStart.position) {
            case 'left':
                this.cropper.x1 = Math.min(this.moveStart.x1 + diffX, this.cropper.x2 - this.cropperScaledMinWidth);
                break;
            case 'topleft':
                this.cropper.x1 = Math.min(this.moveStart.x1 + diffX, this.cropper.x2 - this.cropperScaledMinWidth);
                this.cropper.y1 = Math.min(this.moveStart.y1 + diffY, this.cropper.y2 - this.cropperScaledMinHeight);
                break;
            case 'top':
                this.cropper.y1 = Math.min(this.moveStart.y1 + diffY, this.cropper.y2 - this.cropperScaledMinHeight);
                break;
            case 'topright':
                this.cropper.x2 = Math.max(this.moveStart.x2 + diffX, this.cropper.x1 + this.cropperScaledMinWidth);
                this.cropper.y1 = Math.min(this.moveStart.y1 + diffY, this.cropper.y2 - this.cropperScaledMinHeight);
                break;
            case 'right':
                this.cropper.x2 = Math.max(this.moveStart.x2 + diffX, this.cropper.x1 + this.cropperScaledMinWidth);
                break;
            case 'bottomright':
                this.cropper.x2 = Math.max(this.moveStart.x2 + diffX, this.cropper.x1 + this.cropperScaledMinWidth);
                this.cropper.y2 = Math.max(this.moveStart.y2 + diffY, this.cropper.y1 + this.cropperScaledMinHeight);
                break;
            case 'bottom':
                this.cropper.y2 = Math.max(this.moveStart.y2 + diffY, this.cropper.y1 + this.cropperScaledMinHeight);
                break;
            case 'bottomleft':
                this.cropper.x1 = Math.min(this.moveStart.x1 + diffX, this.cropper.x2 - this.cropperScaledMinWidth);
                this.cropper.y2 = Math.max(this.moveStart.y2 + diffY, this.cropper.y1 + this.cropperScaledMinHeight);
                break;
        }
        if (this.maintainAspectRatio) {
            this.checkAspectRatio();
        }
    }
    /**
     * @return {?}
     */
    checkAspectRatio() {
        let /** @type {?} */ overflowX = 0;
        let /** @type {?} */ overflowY = 0;
        switch (this.moveStart.position) {
            case 'top':
                this.cropper.x2 = this.cropper.x1 + (this.cropper.y2 - this.cropper.y1) * this.aspectRatio;
                overflowX = Math.max(this.cropper.x2 - this.maxSize.width, 0);
                overflowY = Math.max(0 - this.cropper.y1, 0);
                if (overflowX > 0 || overflowY > 0) {
                    this.cropper.x2 -= (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;
                    this.cropper.y1 += (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;
                }
                break;
            case 'bottom':
                this.cropper.x2 = this.cropper.x1 + (this.cropper.y2 - this.cropper.y1) * this.aspectRatio;
                overflowX = Math.max(this.cropper.x2 - this.maxSize.width, 0);
                overflowY = Math.max(this.cropper.y2 - this.maxSize.height, 0);
                if (overflowX > 0 || overflowY > 0) {
                    this.cropper.x2 -= (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;
                    this.cropper.y2 -= (overflowY * this.aspectRatio) > overflowX ? overflowY : (overflowX / this.aspectRatio);
                }
                break;
            case 'topleft':
                this.cropper.y1 = this.cropper.y2 - (this.cropper.x2 - this.cropper.x1) / this.aspectRatio;
                overflowX = Math.max(0 - this.cropper.x1, 0);
                overflowY = Math.max(0 - this.cropper.y1, 0);
                if (overflowX > 0 || overflowY > 0) {
                    this.cropper.x1 += (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;
                    this.cropper.y1 += (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;
                }
                break;
            case 'topright':
                this.cropper.y1 = this.cropper.y2 - (this.cropper.x2 - this.cropper.x1) / this.aspectRatio;
                overflowX = Math.max(this.cropper.x2 - this.maxSize.width, 0);
                overflowY = Math.max(0 - this.cropper.y1, 0);
                if (overflowX > 0 || overflowY > 0) {
                    this.cropper.x2 -= (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;
                    this.cropper.y1 += (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;
                }
                break;
            case 'right':
            case 'bottomright':
                this.cropper.y2 = this.cropper.y1 + (this.cropper.x2 - this.cropper.x1) / this.aspectRatio;
                overflowX = Math.max(this.cropper.x2 - this.maxSize.width, 0);
                overflowY = Math.max(this.cropper.y2 - this.maxSize.height, 0);
                if (overflowX > 0 || overflowY > 0) {
                    this.cropper.x2 -= (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;
                    this.cropper.y2 -= (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;
                }
                break;
            case 'left':
            case 'bottomleft':
                this.cropper.y2 = this.cropper.y1 + (this.cropper.x2 - this.cropper.x1) / this.aspectRatio;
                overflowX = Math.max(0 - this.cropper.x1, 0);
                overflowY = Math.max(this.cropper.y2 - this.maxSize.height, 0);
                if (overflowX > 0 || overflowY > 0) {
                    this.cropper.x1 += (overflowY * this.aspectRatio) > overflowX ? (overflowY * this.aspectRatio) : overflowX;
                    this.cropper.y2 -= (overflowY * this.aspectRatio) > overflowX ? overflowY : overflowX / this.aspectRatio;
                }
                break;
        }
    }
    /**
     * @return {?}
     */
    doAutoCrop() {
        if (this.autoCrop) {
            this.crop();
        }
    }
    /**
     * @param {?=} outputType
     * @return {?}
     */
    crop(outputType = this.outputType) {
        if (this.sourceImage.nativeElement && this.originalImage != null) {
            this.startCropImage.emit();
            const /** @type {?} */ imagePosition = this.getImagePosition();
            const /** @type {?} */ width = imagePosition.x2 - imagePosition.x1;
            const /** @type {?} */ height = imagePosition.y2 - imagePosition.y1;
            const /** @type {?} */ cropCanvas = (document.createElement('canvas'));
            cropCanvas.width = width;
            cropCanvas.height = height;
            const /** @type {?} */ ctx = cropCanvas.getContext('2d');
            if (ctx) {
                if (this.backgroundColor != null) {
                    ctx.fillStyle = this.backgroundColor;
                    ctx.fillRect(0, 0, width, height);
                }
                ctx.drawImage(this.originalImage, imagePosition.x1, imagePosition.y1, width, height, 0, 0, width, height);
                const /** @type {?} */ output = { width, height, imagePosition, cropperPosition: Object.assign({}, this.cropper) };
                const /** @type {?} */ resizeRatio = this.getResizeRatio(width, height);
                if (resizeRatio !== 1) {
                    output.width = Math.round(width * resizeRatio);
                    output.height = this.maintainAspectRatio
                        ? Math.round(output.width / this.aspectRatio)
                        : Math.round(height * resizeRatio);
                    resizeCanvas(cropCanvas, output.width, output.height);
                }
                return this.cropToOutputType(outputType, cropCanvas, output);
            }
        }
        return null;
    }
    /**
     * @return {?}
     */
    getImagePosition() {
        const /** @type {?} */ sourceImageElement = this.sourceImage.nativeElement;
        const /** @type {?} */ ratio = this.originalSize.width / sourceImageElement.offsetWidth;
        return {
            x1: Math.round(this.cropper.x1 * ratio),
            y1: Math.round(this.cropper.y1 * ratio),
            x2: Math.min(Math.round(this.cropper.x2 * ratio), this.originalSize.width),
            y2: Math.min(Math.round(this.cropper.y2 * ratio), this.originalSize.height)
        };
    }
    /**
     * @param {?} outputType
     * @param {?} cropCanvas
     * @param {?} output
     * @return {?}
     */
    cropToOutputType(outputType, cropCanvas, output) {
        switch (outputType) {
            case 'file':
                return this.cropToFile(cropCanvas)
                    .then((result) => {
                    output.file = result;
                    this.imageCropped.emit(output);
                    return output;
                });
            case 'both':
                output.base64 = this.cropToBase64(cropCanvas);
                return this.cropToFile(cropCanvas)
                    .then((result) => {
                    output.file = result;
                    this.imageCropped.emit(output);
                    return output;
                });
            default:
                output.base64 = this.cropToBase64(cropCanvas);
                this.imageCropped.emit(output);
                return output;
        }
    }
    /**
     * @param {?} cropCanvas
     * @return {?}
     */
    cropToBase64(cropCanvas) {
        const /** @type {?} */ imageBase64 = cropCanvas.toDataURL('image/' + this.format, this.getQuality());
        this.imageCroppedBase64.emit(imageBase64);
        return imageBase64;
    }
    /**
     * @param {?} cropCanvas
     * @return {?}
     */
    cropToFile(cropCanvas) {
        return this.getCanvasBlob(cropCanvas)
            .then((result) => {
            if (result) {
                this.imageCroppedFile.emit(result);
            }
            return result;
        });
    }
    /**
     * @param {?} cropCanvas
     * @return {?}
     */
    getCanvasBlob(cropCanvas) {
        return new Promise((resolve) => {
            cropCanvas.toBlob((result) => this.zone.run(() => resolve(result)), 'image/' + this.format, this.getQuality());
        });
    }
    /**
     * @return {?}
     */
    getQuality() {
        return Math.min(1, Math.max(0, this.imageQuality / 100));
    }
    /**
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    getResizeRatio(width, height) {
        if (this.resizeToWidth > 0) {
            if (!this.onlyScaleDown || width > this.resizeToWidth) {
                return this.resizeToWidth / width;
            }
        }
        else if (this.resizeToHeight > 0) {
            if (!this.onlyScaleDown || height > this.resizeToHeight) {
                return this.resizeToHeight / height;
            }
        }
        return 1;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getClientX(event) {
        return event.clientX || event.touches && event.touches[0] && event.touches[0].clientX;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getClientY(event) {
        return event.clientY || event.touches && event.touches[0] && event.touches[0].clientY;
    }
}
ImageCropperComponent.decorators = [
    { type: Component, args: [{
                selector: 'image-cropper',
                template: `
      <div [style.background]="imageVisible && backgroundColor">
          <img
              #sourceImage
              class="source-image"
              [src]="safeImgDataUrl"
              [style.visibility]="imageVisible ? 'visible' : 'hidden'"
              (load)="imageLoadedInView()"
          />
          <div class="cropper"
               *ngIf="imageVisible"
               [class.rounded]="roundCropper"
               [style.top.px]="cropper.y1"
               [style.left.px]="cropper.x1"
               [style.width.px]="cropper.x2 - cropper.x1"
               [style.height.px]="cropper.y2 - cropper.y1"
               [style.margin-left]="alignImage === 'center' ? marginLeft : null"
               [style.visibility]="imageVisible ? 'visible' : 'hidden'"
          >
              <div
                      (mousedown)="startMove($event, 'move')"
                      (touchstart)="startMove($event, 'move')"
                      class="move"
              >&nbsp;</div>
              <span
                      class="resize topleft"
                      (mousedown)="startMove($event, 'resize', 'topleft')"
                      (touchstart)="startMove($event, 'resize', 'topleft')"
              ><span class="square"></span></span>
              <span
                      class="resize top"
              ><span class="square"></span></span>
              <span
                      class="resize topright"
                      (mousedown)="startMove($event, 'resize', 'topright')"
                      (touchstart)="startMove($event, 'resize', 'topright')"
              ><span class="square"></span></span>
              <span
                      class="resize right"
              ><span class="square"></span></span>
              <span
                      class="resize bottomright"
                      (mousedown)="startMove($event, 'resize', 'bottomright')"
                      (touchstart)="startMove($event, 'resize', 'bottomright')"
              ><span class="square"></span></span>
              <span
                      class="resize bottom"
              ><span class="square"></span></span>
              <span
                      class="resize bottomleft"
                      (mousedown)="startMove($event, 'resize', 'bottomleft')"
                      (touchstart)="startMove($event, 'resize', 'bottomleft')"
              ><span class="square"></span></span>
              <span
                      class="resize left"
              ><span class="square"></span></span>
              <span
                      class="resize-bar top"
                      (mousedown)="startMove($event, 'resize', 'top')"
                      (touchstart)="startMove($event, 'resize', 'top')"
              ></span>
              <span
                      class="resize-bar right"
                      (mousedown)="startMove($event, 'resize', 'right')"
                      (touchstart)="startMove($event, 'resize', 'right')"
              ></span>
              <span
                      class="resize-bar bottom"
                      (mousedown)="startMove($event, 'resize', 'bottom')"
                      (touchstart)="startMove($event, 'resize', 'bottom')"
              ></span>
              <span
                      class="resize-bar left"
                      (mousedown)="startMove($event, 'resize', 'left')"
                      (touchstart)="startMove($event, 'resize', 'left')"
              ></span>
          </div>
      </div>
    `,
                styles: [`
      :host {
        display: -webkit-box;
        display: -ms-flexbox;
        display: flex;
        position: relative;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
        overflow: hidden;
        padding: 5px;
        text-align: center;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none; }
        :host > div {
          position: relative;
          width: 100%; }
          :host > div img.source-image {
            max-width: 100%;
            max-height: 100%; }
        :host .cropper {
          position: absolute;
          display: -webkit-box;
          display: -ms-flexbox;
          display: flex;
          color: #53535C;
          background: transparent;
          outline-color: rgba(255, 255, 255, 0.3);
          outline-width: 100vw;
          outline-style: solid;
          -ms-touch-action: none;
              touch-action: none; }
          @media (orientation: portrait) {
            :host .cropper {
              outline-width: 100vh; } }
          :host .cropper:after {
            position: absolute;
            content: '';
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            pointer-events: none;
            border: dashed 1px;
            opacity: .75;
            color: inherit;
            z-index: 1; }
          :host .cropper .move {
            width: 100%;
            cursor: move;
            border: 1px solid rgba(255, 255, 255, 0.5); }
          :host .cropper .resize {
            position: absolute;
            display: inline-block;
            line-height: 6px;
            padding: 8px;
            opacity: .85;
            z-index: 1; }
            :host .cropper .resize .square {
              display: inline-block;
              background: #53535C;
              width: 6px;
              height: 6px;
              border: 1px solid rgba(255, 255, 255, 0.5);
              -webkit-box-sizing: content-box;
                      box-sizing: content-box; }
            :host .cropper .resize.topleft {
              top: -12px;
              left: -12px;
              cursor: nwse-resize; }
            :host .cropper .resize.top {
              top: -12px;
              left: calc(50% - 12px);
              cursor: ns-resize; }
            :host .cropper .resize.topright {
              top: -12px;
              right: -12px;
              cursor: nesw-resize; }
            :host .cropper .resize.right {
              top: calc(50% - 12px);
              right: -12px;
              cursor: ew-resize; }
            :host .cropper .resize.bottomright {
              bottom: -12px;
              right: -12px;
              cursor: nwse-resize; }
            :host .cropper .resize.bottom {
              bottom: -12px;
              left: calc(50% - 12px);
              cursor: ns-resize; }
            :host .cropper .resize.bottomleft {
              bottom: -12px;
              left: -12px;
              cursor: nesw-resize; }
            :host .cropper .resize.left {
              top: calc(50% - 12px);
              left: -12px;
              cursor: ew-resize; }
          :host .cropper .resize-bar {
            position: absolute;
            z-index: 1; }
            :host .cropper .resize-bar.top {
              top: -11px;
              left: 11px;
              width: calc(100% - 22px);
              height: 22px;
              cursor: ns-resize; }
            :host .cropper .resize-bar.right {
              top: 11px;
              right: -11px;
              height: calc(100% - 22px);
              width: 22px;
              cursor: ew-resize; }
            :host .cropper .resize-bar.bottom {
              bottom: -11px;
              left: 11px;
              width: calc(100% - 22px);
              height: 22px;
              cursor: ns-resize; }
            :host .cropper .resize-bar.left {
              top: 11px;
              left: -11px;
              height: calc(100% - 22px);
              width: 22px;
              cursor: ew-resize; }
          :host .cropper.rounded {
            outline-color: transparent; }
            :host .cropper.rounded:after {
              border-radius: 100%;
              -webkit-box-shadow: 0 0 0 100vw rgba(255, 255, 255, 0.3);
                      box-shadow: 0 0 0 100vw rgba(255, 255, 255, 0.3); }
              @media (orientation: portrait) {
                :host .cropper.rounded:after {
                  -webkit-box-shadow: 0 0 0 100vh rgba(255, 255, 255, 0.3);
                          box-shadow: 0 0 0 100vh rgba(255, 255, 255, 0.3); } }
            :host .cropper.rounded .move {
              border-radius: 100%; }
    `],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/**
 * @nocollapse
 */
ImageCropperComponent.ctorParameters = () => [
    { type: DomSanitizer, },
    { type: ChangeDetectorRef, },
    { type: NgZone, },
];
ImageCropperComponent.propDecorators = {
    'sourceImage': [{ type: ViewChild, args: ['sourceImage',] },],
    'imageFileChanged': [{ type: Input },],
    'imageChangedEvent': [{ type: Input },],
    'imageBase64': [{ type: Input },],
    'format': [{ type: Input },],
    'outputType': [{ type: Input },],
    'maintainAspectRatio': [{ type: Input },],
    'aspectRatio': [{ type: Input },],
    'resizeToWidth': [{ type: Input },],
    'resizeToHeight': [{ type: Input },],
    'cropperMinWidth': [{ type: Input },],
    'cropperMinHeight': [{ type: Input },],
    'roundCropper': [{ type: Input },],
    'onlyScaleDown': [{ type: Input },],
    'imageQuality': [{ type: Input },],
    'autoCrop': [{ type: Input },],
    'backgroundColor': [{ type: Input },],
    'containWithinAspectRatio': [{ type: Input },],
    'cropper': [{ type: Input },],
    'alignImage': [{ type: HostBinding, args: ['style.text-align',] }, { type: Input },],
    'startCropImage': [{ type: Output },],
    'imageCropped': [{ type: Output },],
    'imageCroppedBase64': [{ type: Output },],
    'imageCroppedFile': [{ type: Output },],
    'imageLoaded': [{ type: Output },],
    'cropperReady': [{ type: Output },],
    'loadImageFailed': [{ type: Output },],
    'onResize': [{ type: HostListener, args: ['window:resize',] },],
    'moveImg': [{ type: HostListener, args: ['document:mousemove', ['$event'],] }, { type: HostListener, args: ['document:touchmove', ['$event'],] },],
    'moveStop': [{ type: HostListener, args: ['document:mouseup',] }, { type: HostListener, args: ['document:touchend',] },],
};

class ImageCropperModule {
}
ImageCropperModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ImageCropperComponent
                ],
                exports: [
                    ImageCropperComponent
                ]
            },] },
];
/**
 * @nocollapse
 */
ImageCropperModule.ctorParameters = () => [];

/**
 * Generated bundle index. Do not edit.
 */

export { ImageCropperModule, ImageCropperComponent };
//# sourceMappingURL=ng2-image-crop.js.map
